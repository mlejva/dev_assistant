"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeDefaultAppDirectory = exports.statOrNull = exports.getElectronVersion = exports.debug7z = exports.debug = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

let getElectronVersion = exports.getElectronVersion = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (packageData, packageJsonPath) {
        const build = packageData.build;
        // build is required, but this check is performed later, so, we should check for null
        if (build != null && build.electronVersion != null) {
            return build.electronVersion;
        }
        for (let name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
            try {
                return (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)((_path || _load_path()).join((_path || _load_path()).dirname(packageJsonPath), "node_modules", name, "package.json"))).version;
            } catch (e) {
                if (e.code !== "ENOENT") {
                    (0, (_log || _load_log()).warn)(`Cannot read electron version from ${ name } package.json: ${ e.message }`);
                }
            }
        }
        const electronPrebuiltDep = findFromElectronPrebuilt(packageData);
        if (electronPrebuiltDep == null) {
            throw new Error("Cannot find electron dependency to get electron version in the '" + packageJsonPath + "'");
        }
        const firstChar = electronPrebuiltDep[0];
        return firstChar === "^" || firstChar === "~" ? electronPrebuiltDep.substring(1) : electronPrebuiltDep;
    });

    return function getElectronVersion(_x3, _x4) {
        return _ref.apply(this, arguments);
    };
})();

let statOrNull = exports.statOrNull = (() => {
    var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (file) {
        try {
            return yield (0, (_fsExtraP || _load_fsExtraP()).stat)(file);
        } catch (e) {
            if (e.code === "ENOENT") {
                return null;
            } else {
                throw e;
            }
        }
    });

    return function statOrNull(_x5) {
        return _ref2.apply(this, arguments);
    };
})();

let computeDefaultAppDirectory = exports.computeDefaultAppDirectory = (() => {
    var _ref3 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (projectDir, userAppDir) {
        if (userAppDir != null) {
            const absolutePath = (_path || _load_path()).resolve(projectDir, userAppDir);
            const stat = yield statOrNull(absolutePath);
            if (stat == null) {
                throw new Error(`Application directory ${ userAppDir } doesn't exists`);
            } else if (!stat.isDirectory()) {
                throw new Error(`Application directory ${ userAppDir } is not a directory`);
            } else if (projectDir === absolutePath) {
                (0, (_log || _load_log()).warn)(`Specified application directory "${ userAppDir }" equals to project dir â€” superfluous or wrong configuration`);
            }
            return absolutePath;
        }
        for (let dir of DEFAULT_APP_DIR_NAMES) {
            const absolutePath = (_path || _load_path()).join(projectDir, dir);
            const packageJson = (_path || _load_path()).join(absolutePath, "package.json");
            const stat = yield statOrNull(packageJson);
            if (stat != null && stat.isFile()) {
                return absolutePath;
            }
        }
        return projectDir;
    });

    return function computeDefaultAppDirectory(_x6, _x7) {
        return _ref3.apply(this, arguments);
    };
})();

exports.installDependencies = installDependencies;
exports.getGypEnv = getGypEnv;
exports.spawnNpmProduction = spawnNpmProduction;
exports.removePassword = removePassword;
exports.exec = exec;
exports.doSpawn = doSpawn;
exports.spawn = spawn;
exports.handleProcess = handleProcess;
exports.use = use;
exports.debug7zArgs = debug7zArgs;
exports.getTempName = getTempName;
exports.isEmptyOrSpaces = isEmptyOrSpaces;
exports.unlinkIfExists = unlinkIfExists;
exports.asArray = asArray;
exports.isCi = isCi;

var _child_process;

function _load_child_process() {
    return _child_process = require("child_process");
}

var _os;

function _load_os() {
    return _os = require("os");
}

var _path;

function _load_path() {
    return _path = _interopRequireWildcard(require("path"));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _chalk;

function _load_chalk() {
    return _chalk = require("chalk");
}

var _debug2;

function _load_debug() {
    return _debug2 = _interopRequireDefault(require("debug"));
}

var _log;

function _load_log() {
    return _log = require("./log");
}

var _crypto;

function _load_crypto() {
    return _crypto = require("crypto");
}

require("source-map-support/register");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = exports.debug = (0, (_debug2 || _load_debug()).default)("electron-builder");
const debug7z = exports.debug7z = (0, (_debug2 || _load_debug()).default)("electron-builder:7z");
const DEFAULT_APP_DIR_NAMES = ["app", "www"];
function installDependencies(appDir, electronVersion) {
    let arch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.arch;
    let forceBuildFromSource = arguments[3];
    let command = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "install";

    return (0, (_log || _load_log()).task)(`${ command === "install" ? "Installing" : "Rebuilding" } app dependencies for arch ${ arch } to ${ appDir }`, spawnNpmProduction(command, appDir, forceBuildFromSource, getGypEnv(electronVersion, arch)));
}
function getGypEnv(electronVersion, arch) {
    const gypHome = (_path || _load_path()).join((0, (_os || _load_os()).homedir)(), ".electron-gyp");
    return Object.assign({}, process.env, {
        npm_config_disturl: "https://atom.io/download/atom-shell",
        npm_config_target: electronVersion,
        npm_config_runtime: "electron",
        npm_config_arch: arch,
        HOME: gypHome,
        USERPROFILE: gypHome
    });
}
function spawnNpmProduction(command, appDir, forceBuildFromSource, env) {
    let npmExecPath = process.env.npm_execpath || process.env.NPM_CLI_JS;
    const npmExecArgs = [command, "--production"];
    if (npmExecPath == null || !(npmExecPath.indexOf("yarn") !== -1)) {
        if (process.env.NPM_NO_BIN_LINKS === "true") {
            npmExecArgs.push("--no-bin-links");
        }
        npmExecArgs.push("--cache-min", "999999999");
    }
    if (npmExecPath == null) {
        npmExecPath = process.platform === "win32" ? "npm.cmd" : "npm";
    } else {
        npmExecArgs.unshift(npmExecPath);
        npmExecPath = process.env.npm_node_execpath || process.env.NODE_EXE || "node";
    }
    if (forceBuildFromSource) {
        npmExecArgs.push("--build-from-source");
    }
    return spawn(npmExecPath, npmExecArgs, {
        cwd: appDir,
        env: env || process.env
    });
}
function removePassword(input) {
    return input.replace(/(-P |pass:|\/p|-pass )([^ ]+)/, function (match, p1, p2) {
        return `${ p1 }${ (0, (_crypto || _load_crypto()).createHash)("sha256").update(p2).digest("hex") } (sha256 hash)`;
    });
}
function exec(file, args, options) {
    if (debug.enabled) {
        debug(`Executing ${ file } ${ args == null ? "" : removePassword(args.join(" ")) }`);
    }
    return new (_bluebirdLstC2 || _load_bluebirdLstC2()).default((resolve, reject) => {
        (0, (_child_process || _load_child_process()).execFile)(file, args, options, function (error, stdout, stderr) {
            if (error == null) {
                if (debug.enabled) {
                    if (stderr.length !== 0) {
                        (0, (_log || _load_log()).log)(stderr);
                    }
                    if (stdout.length !== 0) {
                        (0, (_log || _load_log()).log)(stdout);
                    }
                }
                resolve(stdout);
            } else {
                let message = (0, (_chalk || _load_chalk()).red)(removePassword(`Exit code: ${ error.code }. ${ error.message }`));
                if (stdout.length !== 0) {
                    message += `\n${ (0, (_chalk || _load_chalk()).yellow)(stdout) }`;
                }
                if (stderr.length !== 0) {
                    message += `\n${ (0, (_chalk || _load_chalk()).red)(stderr) }`;
                }
                reject(new Error(message));
            }
        });
    });
}
function doSpawn(command, args, options, pipeInput) {
    if (options == null) {
        options = {};
    }
    if (options.stdio == null) {
        options.stdio = [pipeInput ? "pipe" : "ignore", debug.enabled ? "inherit" : "pipe", "pipe"];
    }
    if (debug.enabled) {
        debug(`Spawning ${ command } ${ removePassword(args.join(" ")) }`);
    }
    return (0, (_child_process || _load_child_process()).spawn)(command, args, options);
}
function spawn(command, args, options) {
    return new (_bluebirdLstC2 || _load_bluebirdLstC2()).default((resolve, reject) => {
        handleProcess("close", doSpawn(command, args || [], options), command, resolve, reject);
    });
}
function handleProcess(event, childProcess, command, resolve, reject) {
    childProcess.on("error", reject);
    let out = "";
    if (!debug.enabled && childProcess.stdout != null) {
        childProcess.stdout.on("data", data => {
            out += data;
        });
    }
    let errorOut = "";
    if (childProcess.stderr != null) {
        childProcess.stderr.on("data", data => {
            errorOut += data;
        });
    }
    childProcess.once(event, code => {
        if (code === 0 && debug.enabled) {
            debug(`${ command } (${ childProcess.pid }) exited with code ${ code }`);
        }
        if (code !== 0) {
            function formatOut(text, title) {
                if (text.length === 0) {
                    return "";
                } else {
                    return `\n${ title }:\n${ text }`;
                }
            }
            reject(new Error(`${ command } exited with code ${ code }${ formatOut(out, "Output") }${ formatOut(errorOut, "Error output") }`));
        } else if (resolve != null) {
            resolve();
        }
    });
}

function findFromElectronPrebuilt(packageData) {
    for (let name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
        const devDependencies = packageData.devDependencies;
        let dep = devDependencies == null ? null : devDependencies[name];
        if (dep == null) {
            const dependencies = packageData.dependencies;
            dep = dependencies == null ? null : dependencies[name];
        }
        if (dep != null) {
            return dep;
        }
    }
    return null;
}
function use(value, task) {
    return value == null ? null : task(value);
}
function debug7zArgs(command) {
    const args = [command, "-bd"];
    if (debug7z.enabled) {
        args.push("-bb3");
    } else if (!debug.enabled) {
        args.push("-bb0");
    }
    return args;
}
let tmpDirCounter = 0;
// add date to avoid use stale temp dir
const tempDirPrefix = `${ process.pid.toString(16) }-${ Date.now().toString(16) }`;
function getTempName(prefix) {
    return `${ prefix == null ? "" : `${ prefix }-` }${ tempDirPrefix }-${ (tmpDirCounter++).toString(16) }`;
}
function isEmptyOrSpaces(s) {
    return s == null || s.trim().length === 0;
}
function unlinkIfExists(file) {
    return (0, (_fsExtraP || _load_fsExtraP()).unlink)(file).catch(() => {
        // ignore
    });
}
function asArray(v) {
    if (v == null) {
        return [];
    } else if (Array.isArray(v)) {
        return v;
    } else {
        return [v];
    }
}
function isCi() {
    return (process.env.CI || "").toLowerCase() === "true";
}
//# sourceMappingURL=util.js.map