"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LinuxPackager = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

var _path;

function _load_path() {
    return _path = _interopRequireWildcard(require("path"));
}

var _platformPackager;

function _load_platformPackager() {
    return _platformPackager = require("./platformPackager");
}

var _metadata;

function _load_metadata() {
    return _metadata = require("./metadata");
}

var _targetFactory;

function _load_targetFactory() {
    return _targetFactory = require("./targets/targetFactory");
}

var _LinuxTargetHelper;

function _load_LinuxTargetHelper() {
    return _LinuxTargetHelper = require("./targets/LinuxTargetHelper");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _sanitizeFilename;

function _load_sanitizeFilename() {
    return _sanitizeFilename = _interopRequireDefault(require("sanitize-filename"));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LinuxPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        super(info);
        let executableName = this.platformSpecificBuildOptions.executableName;
        this.executableName = (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(executableName == null ? this.appInfo.name : executableName);
    }
    normalizePlatformSpecificBuildOptions(options) {
        if (options != null && options.description != null) {
            return options;
        } else {
            return Object.assign({
                description: this.info.appInfo.description
            }, options);
        }
    }
    createTargets(targets, mapper, cleanupTasks) {
        for (let name of targets) {
            if (name === "dir") {
                continue;
            }
            let helper;
            const getHelper = () => {
                if (helper == null) {
                    helper = new (_LinuxTargetHelper || _load_LinuxTargetHelper()).LinuxTargetHelper(this);
                }
                return helper;
            };
            if (name === (_targetFactory || _load_targetFactory()).DEFAULT_TARGET || name === "appimage") {
                const targetClass = require("./targets/appImage").default;
                mapper("appimage", outDir => new targetClass(this, getHelper(), outDir));
            } else if (name === "deb" || name === "rpm" || name === "sh" || name === "freebsd" || name === "pacman" || name === "apk" || name === "p5p") {
                const targetClass = require("./targets/fpm").default;
                mapper(name, outDir => new targetClass(name, this, getHelper(), outDir));
            } else {
                mapper(name, () => (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name));
            }
        }
    }
    get platform() {
        return (_metadata || _load_metadata()).Platform.LINUX;
    }
    pack(outDir, arch, targets, postAsyncTasks) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const appOutDir = _this.computeAppOutDir(outDir, arch);
            yield _this.doPack(outDir, appOutDir, _this.platform.nodeName, arch, _this.platformSpecificBuildOptions);
            postAsyncTasks.push(_this.packageInDistributableFormat(outDir, appOutDir, arch, targets));
        })();
    }
    postInitApp(appOutDir) {
        return (0, (_fsExtraP || _load_fsExtraP()).rename)((_path || _load_path()).join(appOutDir, "electron"), (_path || _load_path()).join(appOutDir, this.executableName));
    }
    packageInDistributableFormat(outDir, appOutDir, arch, targets) {
        var _this2 = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            // todo fix fpm - if run in parallel, get strange tar errors
            for (let t of targets) {
                if (t instanceof (_platformPackager || _load_platformPackager()).TargetEx) {
                    yield t.build(appOutDir, arch);
                }
            }
            const promises = [];
            // https://github.com/electron-userland/electron-builder/issues/460
            // for some reasons in parallel to fmp we cannot use tar
            for (let t of targets) {
                const target = t.name;
                if (target === "zip" || target === "7z" || target.startsWith("tar.")) {
                    const destination = (_path || _load_path()).join(outDir, _this2.generateName(target, arch, true));
                    promises.push(_this2.archiveApp(target, appOutDir, destination).then(function () {
                        return _this2.dispatchArtifactCreated(destination);
                    }));
                }
            }
            if (promises.length > 0) {
                yield (_bluebirdLstC2 || _load_bluebirdLstC2()).default.all(promises);
            }
        })();
    }
}
exports.LinuxPackager = LinuxPackager; //# sourceMappingURL=linuxPackager.js.map